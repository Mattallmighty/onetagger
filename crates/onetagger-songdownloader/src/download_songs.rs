use anyhow::{Error, Result, bail};
use std::path::{Path, PathBuf};
use std::fs;
use std::process::Command;
use log::{info, warn};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use regex::Regex;

/// Song information structure for CSV/JSON output
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SongInfo {
    pub video_title: String,
    pub video_url: String,
    pub song_title: String,
    pub artist: String,
    pub timestamp: Option<String>,
    pub downloaded: bool,
    pub match_confidence: f32,
}

/// Download songs from a CSV/JSON file generated by query-url
pub fn download_songs(csv_path: &Path, directory: &Path) -> Result<(), Error> {
    info!("Starting song download process");
    
    // Check if directory exists
    if !directory.exists() {
        bail!("Directory does not exist: {:?}", directory);
    }
    
    // Read the CSV/JSON file
    let file_content = fs::read_to_string(csv_path)?;
    let songs: Vec<SongInfo> = if csv_path.extension().unwrap_or_default() == "json" {
        serde_json::from_str(&file_content)?
    } else {
        // Assume CSV format
        parse_csv(&file_content)?
    };
    
    info!("Found {} songs in the input file", songs.len());
    
    // Group songs by video title
    let mut songs_by_video: HashMap<String, Vec<SongInfo>> = HashMap::new();
    for song in songs {
        songs_by_video
            .entry(song.video_title.clone())
            .or_insert_with(Vec::new)
            .push(song);
    }
    
    // Process each video
    for (video_title, songs) in songs_by_video {
        info!("Processing video: {}", video_title);
        
        // Create sanitized folder name
        let folder_name = sanitize_filename(&video_title);
        let video_folder = directory.join(&folder_name);
        
        // Check if folder exists, create if not
        if !video_folder.exists() {
            info!("Creating folder: {:?}", video_folder);
            fs::create_dir_all(&video_folder)?;
        } else {
            info!("Folder already exists: {:?}", video_folder);
        }
        
        // Filter songs that need to be downloaded
        let songs_to_download: Vec<&SongInfo> = songs.iter()
            .filter(|song| song.downloaded)
            .collect();
        
        if songs_to_download.is_empty() {
            info!("No songs marked for download in this video");
            continue;
        }
        
        info!("Downloading {} songs for video: {}", songs_to_download.len(), video_title);
        
        // Download each song
        for song in songs_to_download {
            download_song(song, &video_folder)?;
        }
    }
    
    info!("Song download process completed");
    Ok(())
}

/// Download a single song using yt-dlp or spotdl
fn download_song(song: &SongInfo, output_folder: &Path) -> Result<(), Error> {
    let song_query = format!("{} - {}", song.artist, song.song_title);
    info!("Downloading song: {}", song_query);
    
    // Try to download using yt-dlp with YouTube Music
    let result = download_with_ytdlp(&song_query, output_folder);
    
    if result.is_err() {
        // Fallback to spotdl if yt-dlp fails
        warn!("yt-dlp failed, trying spotdl");
        download_with_spotdl(&song_query, output_folder)?;
    }
    
    info!("Successfully downloaded: {}", song_query);
    Ok(())
}

/// Download a song using yt-dlp
fn download_with_ytdlp(song_query: &str, output_folder: &Path) -> Result<(), Error> {
    let output_template = output_folder.join("%(title)s.%(ext)s").to_string_lossy().to_string();
    
    let status = Command::new("yt-dlp")
        .args([
            "--extract-audio",
            "--audio-format", "mp3",
            "--audio-quality", "0",
            "--embed-metadata",
            "--default-search", "ytsearch",
            "-o", &output_template,
            &format!("ytsearch:{} youtube music", song_query)
        ])
        .status()?;
    
    if !status.success() {
        bail!("yt-dlp command failed with status: {}", status);
    }
    
    Ok(())
}

/// Download a song using spotdl
fn download_with_spotdl(song_query: &str, output_folder: &Path) -> Result<(), Error> {
    let status = Command::new("spotdl")
        .current_dir(output_folder)
        .args([
            "--output", "{title}.{ext}",
            "download",
            song_query
        ])
        .status()?;
    
    if !status.success() {
        bail!("spotdl command failed with status: {}", status);
    }
    
    Ok(())
}

/// Parse CSV content into SongInfo structs
fn parse_csv(content: &str) -> Result<Vec<SongInfo>, Error> {
    let mut reader = csv::Reader::from_reader(content.as_bytes());
    let mut songs = Vec::new();
    
    for result in reader.deserialize() {
        let song: SongInfo = result?;
        songs.push(song);
    }
    
    Ok(songs)
}

/// Convert a title to a valid folder name
fn sanitize_filename(filename: &str) -> String {
    // Replace invalid characters with spaces
    let invalid_chars = Regex::new(r#"[<>:"/\\|?*]"#).unwrap();
    let sanitized = invalid_chars.replace_all(filename, " ").to_string();
    
    // Trim leading/trailing whitespace and dots
    let trimmed = sanitized.trim().trim_matches('.');
    
    // Normalize multiple spaces to a single space
    let normalized = Regex::new(r"\s+").unwrap().replace_all(&trimmed, " ").to_string();
    
    // Ensure the filename is not empty
    if normalized.is_empty() {
        return "Unknown_Title".to_string();
    }
    
    normalized
}

/// Generate CSV/JSON output from query-url results
pub fn generate_output_file(
    url_info: &crate::UrlInfo,
    output_path: &Path,
    directory: Option<&Path>,
    format: &str
) -> Result<PathBuf, Error> {
    let mut songs = Vec::new();
    
    // Process videos and their tracklists
    if let Some(videos) = &url_info.videos {
        for (video_title, video_url, tracklist) in videos {
            let folder_name = sanitize_filename(video_title);
            let folder_exists = if let Some(dir) = directory {
                dir.join(&folder_name).exists()
            } else {
                false
            };
            
            info!("Video title: {}", video_title);
            info!("Formatted video title: {}", folder_name);
            info!("Video title exists in directory: {}", folder_exists);
            
            // Process each track in the tracklist
            for track in tracklist {
                // Extract artist and title
                let (artist, title, timestamp) = parse_track(track);
                
                songs.push(SongInfo {
                    video_title: video_title.clone(),
                    video_url: video_url.clone(),
                    song_title: title,
                    artist,
                    timestamp,
                    downloaded: !folder_exists, // Mark for download if folder doesn't exist
                    match_confidence: 0.0, // Will be updated later
                });
            }
        }
    }
    
    // Create output file
    let output_file = if format == "json" {
        let path = output_path.join("query-url.json");
        let json = serde_json::to_string_pretty(&songs)?;
        fs::write(&path, json)?;
        path
    } else {
        // Default to CSV
        let path = output_path.join("query-url.csv");
        let mut writer = csv::Writer::from_path(&path)?;
        
        for song in &songs {
            writer.serialize(song)?;
        }
        
        writer.flush()?;
        path
    };
    
    info!("Generated output file: {:?}", output_file);
    Ok(output_file)
}

/// Parse a track string into artist, title, and timestamp
fn parse_track(track: &str) -> (String, String, Option<String>) {
    // Extract timestamp if present
    let timestamp_regex = Regex::new(r"^(\d{1,2}:\d{2}(?::\d{2})?)").unwrap();
    let timestamp = timestamp_regex.captures(track).map(|cap| cap[1].to_string());
    
    // Remove timestamp from track string
    let track_without_timestamp = timestamp_regex.replace(track, "").trim().to_string();
    
    // Split by dash to get artist and title
    if let Some(pos) = track_without_timestamp.find(" - ") {
        let artist = track_without_timestamp[..pos].trim().to_string();
        let title = track_without_timestamp[pos+3..].trim().to_string();
        (artist, title, timestamp)
    } else {
        // If no dash, assume the whole string is the title
        (String::new(), track_without_timestamp, timestamp)
    }
}
